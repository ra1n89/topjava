package ru.javawebinar.topjava;

/**
 * @see <a href="https://javaops-demo.ru/topjava">Demo application</a>
 * @see <a href="https://github.com/JavaOPs/topjava">Initial project</a>
 */
public class Main {
    public static void main(String[] args) {
        System.out.format("Hello TopJava Enterprise!");
    }
}


/*
Первые замечания
• коммиты с одинаковыми комментариями - по логике, это должен быть один коммит.
Объединяй, пока не запушил. Варианты:
-- вернись к предыдущему коммиту (в Idea - "Reset current branch to here" - "Soft") и потом сделай один коммит на все изменения.
-- выдели несколько коммитов и сделай "Squash commits"
Но это делай, пока не запушено, т. к. при этом меняется история коммитов.
Замечание по Git учти на будущее, force push уже не делай.
• Optional - это продолжение базовой части задания, расширение функционала. Делай их в одной ветке.
работа приложения
• в приложении будет функционал для операций с пользователями и с их едой. И пусть у всех запросов по еде будет префикс /meals (а по юзерам, соответственно, /users)
Дальше для каждой операции можно сделать еще одну часть (/meals/add, /meals/delete), а можно проще - передавать доп. параметр для желаемого действия (/meals?action=add)
• запускаю, вижу пустую таблицу. Чтобы посмотреть, как реализованный функционал работает, надо вручную внести пачку данных. И так при каждом перезапуске. Сделай так, чтобы изначально какие записи уже были.
• id - внутренняя информация, не надо ее показывать пользователю
• отдельной колонки на Calories per Day>2000 не нужно, excess нужно только для определения правильного цвета строки
• при сохранении описания с кириллицей в таблице кракозябры
см. в уроке ["Проблемы с кодировкой в POST (кракозябры)"](https://github.com/JavaWebinar/topjava/blob/doc/doc/lesson01.md#:~:text=%D0%BA%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%BE%D0%B9%20%D0%B2%20POST%20(-,%D0%BA%D1%80%D0%B0%D0%BA%D0%BE%D0%B7%D1%8F%D0%B1%D1%80%D1%8B,-).)
• при открытии записи на редактирование поля формы должны быть заполнены прошлыми значениями
• 16. После операции delete в браузере должен быть url http:\\localhost:8080\topjava\meals
• текст обычно не пишут верхним регистром, пользователям так неудобно
MealDAO
• абревиатуры в именах пишутся, как обычные слова: первая большая, остальные маленькие
• 1. Если в названии класса есть Meal, не нужно использовать слово meal в методах класса.
• в create/update передавай Meal, а не отдельные поля
• не хватает методов getAll() и get(int id) для получения всех записей и одной по id
• пустые строки оставляют по одной, а перед } она вообще не нужна
MealDAOImp
• не надо Imp в реализациях, если можно указать в имени ее особенность (тут - "в памяти")
• meals и id
-- обязательно должны быть private, т. к. иначе из других классов можно напрямую получать и менять содержимое, а нужно, чтобы к данным был доступ только через методы, реализующие интерфейс MealDAO
-- не делай из static, т. к. они относятся не к классу, а к конкретному объекту
• стр. 12-13 - поле от метода надо отделять одной пустой строкой
• стр. 26 - в начале метода в пустой строке нет необходимости
• сделай Ctrl+Alt+L (автоформат), см. пробелы
• стр. 15:
-- это эквивалентно ++id;
-- ++id - не атомарная операция -> не потокобезопасная. Поищи в java.util.concurrent потокобезопасную обертку над int, которая позволяет атомарно выполнять несколько операций.
• findById - если итерироваться по циклу, и в это время из другого потока удалить элемент из коллекции, можно получить ConcurrentModificationException.
13. Обратите также внимание на то, чтобы реализация вашей коллекции для хранения еды была также потокобезопасной.
Cм. в java.util.concurrent потокобезопасные реализации коллекций.
• обрати внимание, что доступ к элементам по id, и для поиска приходится перебирать всю коллекцию (это делается "под капотом" и в List#remove(Object o) , и в List#indexOf(Object o)). List - не лучший выбор коллекции для хранения, подумай, какая структура данных подошла бы больше
• Meal, стр. 9-10; MealTo, стр. 7-8 - придерживайся одного стиля: или между всеми полями оставляй пустую строку, или не оставляй. Можно разделять группы (но тут явно не группа выделена).
MealsUtil
• filteredByStreamsWithoutFilterByTime почти полностью дублирует filteredByStreams
14 Не делайте дублирование кода MealsUtil. Простой вариант - использовать то, что отсутствие фильтрации - это частный случай фильтрации (когда ничего не отсеивается)...
И filtered в методе без фильтрации не нужно.
• сделай Ctrl+Alt+L (автоформат), см. пробелы в createTo
• web.xml - при именовании тоже старайся придерживаться того принципа, который уже есть в проекте. Уже было <servlet-name>userServlet</servlet-name> (имя класса с маленькой буквы). Сделай имя новых сервлетов в том же стиле
jsp
• стр. 1-7 - шаблон по умолчанию от Idea - не надо
• meals.jsp - стр. 32-40 и 43-52 отличаются только в red/green. Сделай только это через условие, и тут удобно использовать тернарный оператор: ${wtf ? 'color1' : 'color2'}
• deleting.jsp, adding.jsp - не используются, удаляй
сервлеты
• обрати внимание, что в 2-х сервлетах создается свой экземпляр MealDao (а для исправлений добавится в каждый сервлет). А он должен быть один на все приложение - один экземпляр с коллекцией и счетчиком.
Есть возможность шарить объекты между сервлетами через ServletContext, но проще сделать один сервлет на все операции с Meal. Предлагаю использовать этот вариант.
• как реализовать автоматическое обновление.
Сейчас после нажатия кнопки удаления запрос попадает в Deleting#doGet, где в конце выполняется форвард на /meals.jsp. Но таблица получается пустая, т. к. в атрибуты список еды не положен.
Есть форвард, а есть редирект.
Отличия в том, что про форвард клиент (браузер) "не знает", тот же запрос, который принял один сервлет, передается в другой сервлет (jsp - это тоже сервлет). При этом url в адресной строке не меняется, запрос, его параметры, атрибуты остаются прежними.
Редирект - это сервлет сразу отправляет браузеру ответ со статусом 302 и адресом, куда надо перейти. И браузер выполняет еще один запрос - другой. И данные исходного запроса теряются.
А если выполнить редирект на url, по которому отображается таблица с данными, то новый запрос попадет в сервлет, сервлет положит данные в атрибут и сделает форвард на jsp.
Собери все в один сервлет, потом можно будет обсудить его реализацию - более лаконичную. (edited)
 */

/*
Замечания после второго ревью
Доброго!

работа приложения
• id - внутренняя информация, не надо ее показывать пользователю, убери эту колонку
• отдельной колонки на Calories per Day>2000 не нужно, excess нужно только для определения правильного цвета строки
• приложение работает только с контекстом topjava (хардкодишь в сервлете), а должно работать с любым
• кнопка "Update information" не нужна
• текст обычно не пишут верхним регистром (см. стр. создания/апдейта)
• открой таблицу с едой на 2-х разных вкладках, на одной удали или измени запись, на другой открой ее же на апдейт. Форма заполнится неактуальными данными (сколько они в браузере пролежали?). Это неверное поведение. данные для формы должны доставаться и укладываться на форму актуальные из хранилища, а не из браузера.
• если неопознанный action, показывай таблицу с едой


MealDAO
• у интерфейсов все методы public, не надо это писать явно
• getMeals -> getAll

 • в create/update передавай Meal, а не отдельные поля
Потому что репозиторий должен сохранить как есть объект бизнес-логики Meal. У него может меняться состав полей, но сигнатура останется create(Meal meal). А в метод для апдейта, например, каких-то полей мы передавали бы эти поля.

• update - про index см. ниже
• в операциях сохранения (create/update) принято возвращать сохраненный объект
• increaseId - этот метод не относится к операциям над данными о еде. Генерация id для новых записей - внутреннее дело реализации, не надо выставлять это наружу.
Т. е. реализация сама должна сгенерировать новый идентификатор и присвоить его новой записи.


MealDaoInMemory
• в именах из нескольких слов обычно идут от частного к общему - InMemoryMealDao
• убирай неиспользуемые импорты (Ctrl+Alt+O )

 • findById - если итерироваться по циклу по ArrayList (описка), и в это время из другого потока удалить элемент из коллекции, можно получить ConcurrentModificationException.
 Cм. в java.util.concurrent потокобезопасные реализации коллекций.
В этих реализациях нет риска получить ConcurrentModificationException, а методы можно считать атомарными операциями

• по структуре коллекции - да, Map подходит больше, а из реализаций - ConcurrentHahMap, т. к. потокобезопасная.
Не представляю, где там можно было в стримы уйти, поэтому ничего не подскажу.
• getMeals (getMeals) - это никак не должна быть ссылка на коллекцию. А если и отдаешь ссылку (по оплошности), то использовать это нельзя, т. к. зачем тогда MealDaoInMemory, если можно напрямую с коллекцией работать? Сейчас в сервлете используешь indexOf. А если мы поменяем реализацию на другую - в БД, например?
Представь, что бы вернул тогда метод getMeals() и как бы это можно было использовать.
• в update сейчас передается индекс в коллекции, что в корне неверно, т. к. вызывающий код не должен знать подробностей реализации. Сигнатура должна быть такая: update(Meal meal). А реализация сама должна сделать все необходимое, чтобы заменить существующую запись на переданную.


• MealsUtil#main не нужен, удали

jsp
• meals.jsp, стр. 24 -  никогда не используй выражения типа condition == false. Это эквивалентно !condition.

MealServlet
• стр. 24-26 - пустые строки оставляют по одной
• стр. 90-91 - перед } пустая строка не нужна
• mealDao сделай private
:bangbang: meals - убери, это ты выставил в сервлет внутренности MealDaoInMemory, и mealDao можно вообще не использовать.
• инициализацию экземпляра сервлета (нестатических полей) принято делать в методе HttpServlet#init
• стр. 32 - см. константы в LocalTime
• System.out не используй, добавь логгер и пиши в лог (см. UserDervlet)
• стр. 42-52 - тут получаешь данные из браузера и передаешь их дальше на форму. А надо получить идентификатор, достать актуальные данные и положить на форму их. И не отдельными полями, а объектом Meal. Объектом по той же причине, что в dao
• doPost - в ветках if дублируется функционал, вынеси его за пределы условного оператора. И, кстати, с кодом if ("add") else if ("update") возможен и третий вариант, когда ничего из этого. Но вообще тут параметр action избыточен, т. к.

ra1n, [09.10.2024 20:49]
по пришедшим данным о еде (по наличию id) можно определить, это создание или апдейт.
• стр. 67, 80 - formatter с таким паттерном - это стандартный DateTimeFormatter.ISO_LOCAL_DATE_TIME. В этом случае можно использовать метод LocalDateTime#parse без второго параметра (см. док., Ctrl+клик на методе).
 */